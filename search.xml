<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java常见集合系列]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.java集合框架体系图 2.常见Map家族2.1 HashMap&nbsp;&nbsp;&nbsp;&nbsp;HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，HashMap最多只允许一条记录的键为null，允许多条记录的值为null。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&nbsp;&nbsp;&nbsp;&nbsp;HashMap的底层数据结构是数组+链表。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。其put方法的实现过程是，首先根据key的hashcode，进行高位运算，取模运算，并将结果作为数组下标，如果该位置已有值，则通过equals方法比较二者是否相等，如果相等则用新值覆盖旧值，如若不等，则将新建链表节点并插在已存节点的前面。同理，get方法的实现首先计算key的hashcode找到数组下标，通过equals方法比较链表中相等的键，然后返回该节点的value。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，put方法实现时可能存在扩容过程。因为Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。为了解resize机制，先看构造函数参数源码：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int threshold; //所能容纳的key-value对极限&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final float loadFactor; // 负载因子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int modCount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size;&nbsp;&nbsp;&nbsp;&nbsp;首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。&nbsp;&nbsp;&nbsp;&nbsp;结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择。&nbsp;&nbsp;&nbsp;&nbsp;size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。&nbsp;&nbsp;&nbsp;&nbsp;这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。 2.2 LinkedHashMap&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。在LinkedHashMap中，是通过双联表的结构来维护节点的顺序的，其他处理逻辑与HashMap一致，同样也没有锁保护，多线程使用存在风险。 2.3 TreeMap&nbsp;&nbsp;&nbsp;&nbsp;TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。底层是红黑树。 2.4 HashTable&nbsp;&nbsp;&nbsp;&nbsp;Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 3.常见List家族3.1 ArrayList&nbsp;&nbsp;&nbsp;&nbsp;ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。&nbsp;&nbsp;&nbsp;&nbsp;每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并 没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。ArrayList是非同步的（unsynchronized）。特点是：寻址容易，插入和删除困难； 3.2 LinkedList&nbsp;&nbsp;&nbsp;&nbsp;LinkedList实现了List接口，允许null元素，底层是一个链表。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。它也是非同步的。 3.3 Vector&nbsp;&nbsp;&nbsp;&nbsp;Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例 如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该 异常。 3.4 Stack&nbsp;&nbsp;&nbsp;&nbsp;Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得 Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 3.常见Set家族4.1 HashSet&nbsp;&nbsp;&nbsp;&nbsp;它不允许出现重复元素(根据hashCode比较)；&nbsp;&nbsp;&nbsp;&nbsp;不保证集合中元素的顺序&nbsp;&nbsp;&nbsp;&nbsp;允许包含值为null的元素，但最多只能有一个null元素。&nbsp;&nbsp;&nbsp;&nbsp;HashSet的实现是不同步的。&nbsp;&nbsp;&nbsp;&nbsp;HashSet的底层通过HashMap实现的。而HashMap在1.7之前使用的是数组+链表实现，在1.8+使用的数组+链表+红黑树实现。其实也可以这样理解，HashSet的底层实现和HashMap使用的是相同的方式，因为Map是无序的，因此HashSet也无法保证顺序。&nbsp;&nbsp;&nbsp;&nbsp;HashSet的方法，也是借助HashMap的方法来实现的。HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT = new Object();。 4.2 LinkedHashSet&nbsp;&nbsp;&nbsp;&nbsp;对于LinkedHashSet而言，它继承于HashSet、又基于LinkedHashMap来实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同。&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashSet是具有可预知迭代顺序的Set接口的哈希表和链接列表实现。此实现与HashSet的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。此实现不是同步的。 4.3 TreeSet&nbsp;&nbsp;&nbsp;&nbsp;TreeSet类实现 Set 接口，该接口由 TreeMap 实例支持。此类保证排序后的 set 按照升序排列元素，根据使用的构造方法不同，可能会按照元素的自然顺序 进行排序，或按照在创建 set 时所提供的比较器进行排序。&nbsp;&nbsp;&nbsp;&nbsp;TreeSet描述的是Set的一种变体——可以实现排序等功能的集合，它在将对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中.&nbsp;&nbsp;&nbsp;&nbsp;HashSet是基于Hash算法实现的,其性能通常优于TreeSet,我们通常都应该使用HashSet,在我们需要排序的功能时,我门才使用TreeSet;TreeSet是非同步的，线程不安全的。 4.4 HashSet，TreeSet，LinkedHashSet之间的区别&nbsp;&nbsp;&nbsp;&nbsp;HashSet只去重，TreeSet去重并排序，LinkedHashSet去重并保留插入顺序 5.List 、Set、 Map有什么区别和联系&nbsp;&nbsp;&nbsp;&nbsp;list 和set 有共同的父类 它们的用法也是一样的 唯一的不太就是set中不能有相同的元素 list中可以&nbsp;&nbsp;&nbsp;&nbsp;list和set的用途非常广泛 list可以完全代替数组来使用&nbsp;&nbsp;&nbsp;&nbsp;map 是独立的合集 它使用键值对的方式来储存数据 键不能有重复的 值可以用&nbsp;&nbsp;&nbsp;&nbsp;map不像上边两种集合那个用的广泛 不过在servlet 和jsp中map可是绝对的重中之重 页面之间传值全靠map]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法是最经典的算法知识。因为其实现代码短，应该广，在面试中经常会问到排序算法及其相关的问题。一般在面试中最常考的是快速排序和归并排序等基本的排序算法，并且经常要求现场手写基本的排序算法。如果这些问题回答不好，估计面试就凉凉了。所以熟练掌握排序算法思想及其特点并能够熟练地手写代码至关重要。 下面介绍几种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、基数排序的思想，其代码均采用Java实现。 1.冒泡排序1.1.思想 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端 1.2.算法描述比较相邻的元素。如果第一个比第二个大，就交换它们两个；对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；针对所有的元素重复以上的步骤，除了最后一个；重复步骤1~3，直到排序完成 1.3.动画演示 1.4.代码实现public static int[] bubble(int[] a){ int temp = 0; for (int i=0;i&lt;a.length;i++){//遍历整个数组 for (int j=0;j&lt;a.length-1-i;j++){//每次遍历跟相邻比较 if (a[j]&gt;a[j+1]){ //把大的值往后放 temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } }//一次循环后就能把最大值（最小值）浮动到数组尾（头） } return a; } 2.选择排序2.1 思想选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。 2.2算法描述在未排序序列中找到最小（大）元素，存放到排序序列的起始位置从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。 2.3.动画演示 2.4.代码实现 public static int[] select(int[] array){ int temp = 0; for (int i=0;i&lt;array.length;i++){ for (int j=i+1;j&lt;array.length;j++){//每次当前值都和后面所有值比较，找到比它小的就交换 if (array[i]&gt;array[j]){ temp = array[i]; array[i] = array[j]; array[j] = temp; } }//每次循环结束，就能找到相对最小值放在数组起那么 } return array; } //改进选择排序，记录最小值下标，只交换一次 public static int[] select2(int[] array){ int temp = 0; for (int i=0;i&lt;array.length;i++){ int minIndex = i; //记录下标值 for (int j=i+1;j&lt;array.length;j++){ if (array[minIndex]&gt;array[j]){ minIndex = j; } } temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; } return array; } 3.插入排序3.1.思想插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.2.算法描述把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。重复上述过程直到最后一个元素被插入有序子数组中。 3.3.动画演示 3.4.代码实现//直插，总是假设前面是有序的，后面往前找到合适的位置插入 public static int[] insert(int[] a,int n){ int temp = 0 ; int j; for (int i=0;i&lt;n;i++){//遍历全部 temp = a[i+1]; //暂存当前的下一个 j=i; //j从当前开始 while (j&gt;-1&amp;&amp;temp&lt;a[j]){//如果后面的值小于当前值，进入循环 a[j+1] = a[j]; //temp已经存了下一个的值，可以直接覆盖 j--; } a[j+1] = temp; //恢复覆盖的值 } return a; } 4.归并排序4.1.思想归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 4.2.算法描述迭代法（Bottom-up）原理如下（假设序列共有n个元素）： 将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素重复步骤2，直到所有元素排序完毕，即序列数为1 4.3.动画演示 4.4.代码实现//归并，借助辅助交换数组,根据k长度进行归并 public static int[] merge(int[] a,int k){//k是分组的长度 int aLeft = 0; //第分组起始下标 int aRight; //a分组终止下标 int bLeft; //b分组起始下标 int bRight; //第分组终止下标 int[] swap = new int[a.length];//等长辅助数组 int m = 0; //m记录辅助数组下标位置 int i,j; //i记录a分组遍历，b记录b分组遍历 while (aLeft+k&lt;=a.length-1){//从相邻分组b起始遍历，将b往a里合并 bLeft = aLeft+k; //b分组的起始下标=第1分组起始+分组长度 aRight = bLeft-1; //a分组的终止是b分组起始往前退1 bRight = (bLeft+k&gt;a.length)? a.length-1:bLeft+k-1;//b分组=b起始+长度，但是不能超高a数组总长度 for (i=aLeft,j=bLeft;i&lt;=aRight&amp;&amp;j&lt;=bRight;m++){//从a分组开始扫描比较 if (a[j]&gt;=a[i]){//如果a分组小，放入辅助数组，a分组前进 swap[m] = a[i]; i++; }else {//如果b分组小，放入辅助数组，b分组前进 swap[m] = a[j]; j++; } } //遍历结束，一定至少有一个分组已经合并完 while (i&lt;=aRight){//如果a分组还没合并完 swap[m++] = a[i++]; //剩余数据压入辅助数组 } while (j&lt;=bRight){//如果b分组还没合并完 swap[m++] = a[j++]; } aLeft = bRight+1;//a,b合并完后下一个新a分组从旧b分组长度+1开始 } //此时所有能完整分组的已经合并完，剩下分组长度不足数的 for (i=aLeft;i&lt;a.length;i++){//从不足数分组起始遍历 swap[m++] = a[i]; //全部压入辅助数组中 } return swap; } //合并长度长1，2,2k... public static int[] mergeSort(int[] a){ int i,k=1; while (k&lt;a.length){ a = merge(a,k ); k = 2*k; } return a; } 5.快速排序5.1.思想快速排序是一个知名度极高的排序算法，其对于大数据的优秀排序性能和相同复杂度算法中相对简单的实现使它注定得到比其他算法更多的宠爱。 5.2.算法描述从数列中挑出一个元素，称为”基准”（pivot），重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 5.3.动画演示 5.4代码实现//快排,从第一个元素开始，比他小的在左边，比他大的在右边，递归左右 public static int[] quick(int[] a,int left,int right){ int temp = a[left];//总是从最左第一个 int i = left; int j = right; while (i&lt;j){ while (i&lt;j&amp;&amp;temp&lt;=a[j]){//从右到左，找第一个比它小的 j--; } if (i&lt;j){//如果找到了 a[i] = a[j];//将比它大的值移到最右左边 i++; //左边距离前进一个单位 } while (i&lt;j&amp;&amp;a[i]&lt;temp){//从左向右，找第一个比它大的 i++; } if (i&lt;j){//如果找到了 a[j] = a[i];//将比他小的移到右边 j--; //右边距离缩短一个单位 } a[i] = temp; //找到了合适的位置放进去，左边都比它小，右边都比它大 } if (i&gt;left)quick(a,left ,i-1 );//递归左边的子集 if (i&lt;right)quick(a,j+1 ,right );//递归右边的子集 return a; } 6.堆排序6.1.思想堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。 6.1.1.堆概念堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。如下图，是一个堆和数组的相互关系：对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标： Parent(i) = floor(i/2)，i 的父节点下标Left(i) = 2i，i 的左子节点下标Right(i) = 2i + 1，i 的右子节点下标二叉堆一般分为两种：最大堆和最小堆。最大堆中的最大元素值出现在根结点（堆顶）堆中每个父节点的元素值都大于等于其孩子结点（如果存在）最小堆中的最小元素值出现在根结点（堆顶）堆中每个父节点的元素值都小于等于其孩子结点（如果存在） 6.2.算法描述堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作： 最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变 6.3.动画演示6.4代码实现//堆排序(最大堆) public static int[] heap(int[] a){ int temp = 0; initHeap(a,a.length ); //2.1初始化堆，将无序序列构造为堆。 for (int i=a.length-1;i&gt;0;i--){ temp = a[0]; //2.2 弹出堆顶 a[0] = a[i]; a[i] = temp; //将最大值放入数组尾 createHeap(a, 0,i );//2.3,缩小建堆范围，重新构建堆 } return a; } //从第一个非叶子节点开始建堆 public static int[] initHeap(int[] a,int n){ for (int i= (a.length-2)/2;i&gt;=0;i--){ a = createHeap(a,i,a.length); } return a; } //以h为建堆顶点,建立并调整堆 public static int[] createHeap(int[] a,int h,int n){ int i,j,tag;//tag循环结束条件（调整节点比左右都大直接出来） i = h; // i是要建堆的节点下标 j=2*i+1; //建堆节点的左孩子 int temp = a[i]; tag = 0; while (j&lt;n&amp;&amp;tag!=1){ if (j&lt;n-1&amp;&amp;a[j]&lt;a[j+1])j++;//比较左右，取大值 if (temp&gt;a[j]){ tag = 1; }else {//调整建堆顶点，向下调整 a[i] = a[j]; i = j; j = 2*i+1; } } a[i] = temp; return a; } 7.希尔排序7.1.思想在希尔排序出现之前，计算机界普遍存在“排序算法不可能突破O(n2)”的观点。希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。希尔排序的提出，主要基于以下两点：插入排序算法在数组基本有序的情况下，可以近似达到O(n)复杂度，效率极高。但插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。 7.2.算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；按增量序列个数k，对序列进行 k 趟排序；每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 7.3.动画演示 7.4代码实现//希尔，把数组按步长分组，每组分别进行直插排序 public static int[] shell(int[]a,int[] spans){ int span; for (int i=0;i&lt;spans.length;i++){//遍历希尔步长次 span = spans[i]; for (int k=0;k&lt;span;k++){//全部数据按照步长分组 for (int j=k;j+span&lt;a.length;j+=span){//对每个分组进行直插排序 int t =j; int temp = a[j+span]; while (t&gt;-1&amp;&amp;a[t]&gt;temp){ a[t+span] = a[t]; t -= span; } a[t+span] = temp; } } } return a; } 8.基数排序8.1.思想基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 8.2算法描述取得数组中的最大数，并取得位数；arr为原始数组，从最低位开始取每个位组成radix数组；对radix进行计数排序（利用计数排序适用于小范围数的特点）； 8.3.动画演示 8.4代码实现基数（桶）借用链式队列数组，按位填入 public static int[] radix(int[] a,int m){//m表示最大整数有m位 LinkedBlockingQueue&lt;Integer&gt;[] bucket = new LinkedBlockingQueue[10];//因为是10进制，所以需要10个桶 for (int i=0;i&lt;bucket.length;i++){ //初始化每个队列 bucket[i] = new LinkedBlockingQueue(); } Integer pop; //保存从桶中弹出的数 for (int i=1;i&lt;=m;i++){ //根据位数遍历 for (int j=0;j&lt;a.length;j++){ //低位开始第i位，取出每个数字对应的位数作为桶下标， double val = Math.floor(a[j]/Math.pow(10,i-1))-10*Math.floor(a[j]/Math.pow(10,i));//取位公式 bucket[(int)val] .add(a[j]); //放入桶中 } int c=0; for (int k=0;k&lt;bucket.length;k++){ //遍历所有桶 while ((pop=bucket[k].poll())!=null){ //取出数据重新放入a中 a[c++] = pop; } } } return a; } 9.算法比较总结]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>tag 算法</tag>
        <tag>tag 排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本命令]]></title>
    <url>%2F2019%2F03%2F06%2Fgit%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[工作区-暂存区-本地仓库-远程仓库关系对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地仓库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。将本地仓库与远程仓库关联，然后可以将本地仓库内容推送到远程仓库中。 本地仓库基本操作创建本地仓库mkdir test #创建本地仓库工作目录 git init #初始化本地仓库 echo &quot;first file&quot; &gt;&gt; #test.txt 在工作目录test里添加文件 git add test.txt #将工作目录里的文件添加到暂存区 git commit -m &quot;first commit&quot; #将暂存区里的文件提交到版本地仓库 删除回退操作修改了文件内容并add了文件,但尚未commit,回退到修改前git reset HEAD test.txt git checkout -- test.txt 修改了文件内容并commit了文件，回退git log #拿到commit-id git reset --hard &quot;commit-id&quot; #执行回退 清空本地仓库git rm test.txt #删了文件，暂存区还有记录 git commit -m &quot;delete&quot; #提交删除，清空暂存区 远程仓库创建ssh key1.ssh-keygen -t rsa &quot;yourmail@example.com&quot; #创建ssh key 2.到用户目录下的.ssh文件夹 复制.pub到github构建ssh key 3.ssh -T git@github.com 测试是否连接成功 创建本地仓库，并提交到github远程仓库mkdir test2 echo &quot;test2&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;test2&quot; git remote add origin yourgithbub@name.git #添加一个新的远程仓库 git push -u origin master #(推送到远程仓库。-u等于关联，后面可以直接git push) 克隆远程仓库，修改文件并提交git clone yourgithub@name.git #克隆远程仓库 cd name #进入目录 echo &quot;clone add file&quot; &gt;&gt; test3.txt git add test3.txt git commit -m &quot;clone&quot; git push 标签关联git tag #列出所有标签 git tag v1.0.1 #新建标签v1.0.1 git tag -a tagName -m &quot;comment&quot; #创建tag并且添加了附注信息 git push origin --tags v1.0.1 #将tag推送到远程仓库 git tag -d tagName #删除tag 分支管理git branch #列出所有分支 git branch name #新建分支name git checkout name #切换到name分支 echo &quot;in branch&quot; &gt;&gt; branch.txt git add branch.txt git commit -m &quot;branch&quot; git push --set-upstream origin name #将name分支提交到远程仓库 check out master git merge name #合并分支 git branch -d name #删除分支 git fetch origin dev:dev #将远程的dev分支拉取到本地的dev分支 git pull origin master:brantest #pull=fetch+merge,将远程的mater分支fetch下来并和branchtest合并]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存模型]]></title>
    <url>%2F2019%2F03%2F06%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.首先看个整体图 2.内存模型解释2.1.程序计数器&nbsp;&nbsp;&nbsp;&nbsp;当前线程所执行字节码的行号指示器，通过改变它的值来选取下一条指令。分支、循环、异常处理、线程恢复等都需要依赖它。它也是唯一一个不会抛出OutOfMemoryError异常的区域。 2.2.虚拟机栈(java栈)&nbsp;&nbsp;&nbsp;&nbsp;java栈描述java方法执行的内存模型。一个方法的执行时，会虚拟机会创建一个栈帧，存储局部变量表，操作数栈等。方法的调用到执行结束，相当于java栈的入栈出栈。该区域可能会产生两种异常。线程请求的栈的深度大于虚拟机允许的最大深度，抛出StackOverflowError。若该栈支持动态拓展（一般都支持），扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。 2.3.本地方法栈&nbsp;&nbsp;&nbsp;&nbsp;本地方法栈与java栈功能差不多，只是java栈为java程序方法服务，而它为本地方法服务。有的虚拟机（如sun HotSpot）甚至会把二者合二为一。 如java栈一样，该区域也会抛StackOverflowError、OutOfMemoryError异常。 2.4.JAVA堆&nbsp;&nbsp;&nbsp;&nbsp;对于大多数应用来说，java堆是虚拟机管理的内存中分配最大的一部分。java堆是被所有线程共享的一块内存区域。&nbsp;&nbsp;&nbsp;&nbsp;虚拟机启动时便创建。存放对象实例，几乎所有的对象实例都在这里分配内存。该区域也是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆。&nbsp;&nbsp;&nbsp;&nbsp;细分出来，该区域可以分为新生代，老年代，新生代可以再分为一个Eden空间，两个Survivor空间（from survivor，to survivor）。不论如何划分，存放的始终是实例对象。进一步划分的目的是利于回收内存，或者更快的分配内存。(内存收集器基本采用分代收集的方法)&nbsp;&nbsp;&nbsp;&nbsp;java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，且堆无法再拓展，将会抛出OutOfMemoryError异常。 2.5.方法区&nbsp;&nbsp;&nbsp;&nbsp;方法区与java堆一样，都是线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT)编译后的代码等数据。java虚拟机规范把方法区描述为java堆的一个逻辑部分，习惯在HotSpot虚拟机上开发的程序员更愿意称其为”永久代”。&nbsp;&nbsp;&nbsp;&nbsp;当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常。 2.6.运行时常量池&nbsp;&nbsp;&nbsp;&nbsp;运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后将进入方法区的运行时常量池中存放。&nbsp;&nbsp;&nbsp;&nbsp;作为方法区的一部分，运行时常量池受内存限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 3.一个对象的一辈子&nbsp;&nbsp;&nbsp;&nbsp;我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。 &nbsp;&nbsp;&nbsp;&nbsp;1、一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。&nbsp;&nbsp;&nbsp;&nbsp;2、并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。&nbsp;&nbsp;&nbsp;&nbsp;3、进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。&nbsp;&nbsp;&nbsp;&nbsp;分区的目的：新生区由于对象产生的比较多并且大都是朝生夕灭的，所以直接采用标记-清理算法。而养老区生命力很强，则采用复制算法，针对不同情况使用不同算法]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp开发过程中的乱码问题及其解决方案]]></title>
    <url>%2F2018%2F10%2F10%2Fjsp%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[jsp开发过程中的乱码问题及其解决方案1.必须先理清的关系jsp开发过程中,我们会看到page指令里有pageEncoding，contentType里的charset（后面一律简称charset),而浏览器自己也可以设置页面的编码格式。首先，pageEncoding表明，你这个文件将以什么编码形式保存起来。charset表明，你希望这里的代码以什么编码展示在浏览器上。浏览器自己也可以设置编码方式，当你的charset与浏览器不对应时就会出现乱码。 2.常见的几种编码 ISO-8895-1编码是单字节编码，因而可以达到数据无损,但不支持中文。 UTF-8编码多字节编码，支持中文等多种语言，是很通用的编码方式 gbk2312编码是针对中文而弄的一种编码 … 3.必须要知道的一些默认编码首先，get请求和post请求携带参数的方式不同（get直接在url上) 对于post请求，中文编码方式会受到上面提到的pageEncoding，charset，以及jsp内置对象request和response的setCharacterEncoding方法影响，后面会具体说明。 对于get请求，其中文编码会受到charset以及Tomcat服务器的配置信息影响，配置的是URLEncoding，在/conf/servlet.xml的文件中。据了解，Tomcat7及以下，默认采用ISO-8895-1,Tomcat8及以上采用UTF-8。 jsp中,request对象获取参数中需要特别注意到的一点是，对于get请求，采用request.getQueryString()得到的参数和用request.getParameter()得到的参数编码是不同的，因为方法getParameter()将会采用Tomcat服务器配置的URLEncoding自动解码一次,而getQueryString()会受到charset的影响 4.正式讲讲jsp中的编码问题 首先强调一点，内置对象的setCharacterEncoding只对post请求有效 对于post请求，当发送端用了response.setCharacterEncoding(Xxx),即设置了响应的编码格式，那么在服务器端，你可以选择用request.setCharacterEncoding(Xxx),即设置请求的编码方式来解决中文乱码问题。这一Xxx是必须一致的，response对应request。又或者，你可以自己手动转码的方式，把通过request.getParameter()得到的乱码数据data采用java.net.URLDecoder.decode(data, “Xxx”)或者new String(data.getBytes(“ISO-8895-1”),”Xxx”)从而解决乱码问题。当发送端没有设置response.setCharacterEncoding，那么此时需要参照contentType里的charset,这里的charset等价于上面的Xxx,依然可以用上述两种方式解决乱码问题。举个例子,A页面charset是utf-8，response.setCharacterEncoding是gbk2312，此时打开浏览器会是乱码，可以设置浏览器的编码为gbk，编码正常，而B页面charset也是utf-8，request.setCharacterEncoding必须是gbk，打印获取到的结果，在浏览器上还是乱码，因为浏览器在上一步被你设置成了gbk，换行utf-8正常。所以尽量控制charset与setCharacterEncoding是一致的 对于get请求，发送端的中文编码取决charset设置的编码方式，假如是utf-8，到了服务端的时候，若使用request.getParameter()，而此时你的Tomcat的URLEncoding是UTF-8,那么会自动用utf-8帮你解码一次，因而是不会出现乱码的情况。此时如果调用getQueryString(),打印的结果就是用charset设置utf-8编码方式编码的结果，需要手动解码回正常中文。 有一种无法挽回的特殊情况是，对于get请求，若发送端你的charset设置的是gbk2312，到了服务器端，假如你的Tomcat的URLEncoding是UTF-8，你用request.getParameter()获取参数，整个过程就等价于数据用了gbk2312编码，却用了utf-8自动解码，这样就会造成数据无法转回来了。当然此时你通过getQueryString()得到的数据通过解gbk2312码是可以得到正常结果的。 5.建议 控制contentType里的charset与pageEncoding与setCharacterEncoding()一致 对于中文数据尽量不用get请求提交，毕竟可能会造成上述说的无法挽回的结果。 可以设置拦截器，对请求统一进行编码，就不用一个页面调用设置编码的函数了]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jsp</tag>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈社团招新]]></title>
    <url>%2F2018%2F09%2F06%2F%E8%B0%88%E7%A4%BE%E5%9B%A2%E6%8B%9B%E6%96%B0%2F</url>
    <content type="text"><![CDATA[1 自从开学后，就开始准备招新事宜，我留任校团委网络中心，已经大三的我，不论当时留下来的原因是什么，如今尘埃落定，居其位,思其责，做其事。我其实很想逃避这些东西，但如今我逃避不了了。谈起招新，谈起扫楼，谈起跟其他组织竞争，可能有人会在背后说闲话，但我只能说，我只是在尽力做我能做的事情，没有恶意，我只是提供了一个选择，一个通往我部门的选择而已。但似乎，从其他人眼中，我所做的似有不妥。可能毕竟是竞争，可能我做的还不够好。 2我渐渐觉得社团是一个很迷的地方。如果一个人，坚持了一开始的想法，那么可能他就是体验社团一年，尝尝新鲜感，留下美好的回忆，然后大二离场。有的人，开始很融入这个社团，然后开始改变自己，改变想法，成功地走上了一条新的路，或者说被社团改造。我不能说这两种情况哪一个比较好，毕竟未来谁能预料地到。社团这条路，一开始，一群人挤着抢着上车，司机也各显神通地邀请，然而讽刺的是，到最后，幸运的人成功的进入了社团，可怜的人，从被抢来抢去，到被抛来抛去，最后再也鼓不起勇气去报其他。而更讽刺的是，某些幸运的人没有做出他应该做到的表现，而当时如果招入的是其他人，结局也又未可知。这时，我们往往会说，这就是命，或者说，缘分使然，感怀亦是徒然。 3不知为何，我开始会想很多东西，考虑很多东西，我开始担心自己做的不够好，我甚至害怕带不起他们。我开始为这些事操心，明明，我应该大胆放手，让他们成长。我似乎很自卑，但在一部分人眼中，我好像也很“完美”。我感觉我变了，我开始想写一些感受，我的话开始变的很多。 4我的大学只选择了一个社团，可能我是无法体会到那些报了多个社团的人的感受，我甚至都无法去评论，因为那样显得很片面。而有的人也是只选择了一个社团，但是他却也局限于只了解这一社团，似有井底之蛙之嫌。谈到社团，却又不得不提归属感一词，有的人愿意为部门付出很多，而且无怨无悔，甚至乐此不疲，而有的人唯恐避之不及。有的人只想得到什么，不打算去付出。我不知道每一个他们是怎么想的，我也不知道他们是否认真考虑过它的意义。或许是我的成长环境决定了我的所思所想，在外人看来觉得完全没有必要去做某些我认为才是真正该做该学的事。但想回来，我应该是个利己主义者，但为何偏偏去替他人担忧他的未来。是因为他们过的比我洒脱，我需要自我安慰自己？我想有部分原因是这样的。可是明明，我对自己的未来都没能把控好，但何苦去评判他人。这一点，我不知道为什么，或者说，我还没能想到这一层。 5走走停停，大学就这么过去了，可能毕业后的自己，回想如今，又是千思百绪，又或者嘲笑自己。甚至于说，多年之后，我才记起，我在大三的招新工作里，写了这么一篇文章。如果现在的我，无意间翻到了初中时的我写的东西，多么稚嫩，却也很美好。]]></content>
      <categories>
        <category>我说</category>
      </categories>
      <tags>
        <tag>生活闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http模拟登陆]]></title>
    <url>%2F2018%2F09%2F03%2Fhttp%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[使用java作为后台语言，实现带验证码的模拟登陆。采用springboot快速开发。简单而言，过程分两步 一、获取验证码图片通过抓包工具如fiddler等，或者直接在浏览器控制台找到获取验证码图片的url。然后后台发起http请求，拿到图片并展示。 如下获取验证码图片函数 private void getImg(HttpServletResponse response){ HttpGet get = new HttpGet(&quot;验证码的url&quot;); try { CloseableHttpResponse res = client.execute(get); HttpEntity entity = res.getEntity(); OutputStream out = response.getOutputStream(); byte[] buffer = new byte[1024]; int end; while ((end=entity.getContent().read(buffer))!=-1){ out.write(buffer); } out.close(); response.setContentType(&quot;image/jpeg&quot;);//设置相应类型,告诉浏览器输出的内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);//设置响应头信息，告诉浏览器不要缓存此内容 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); // 将内存中的图片通过流动形式输出到客户端 } catch (IOException e) { e.printStackTrace(); } 二、模拟登陆通过抓包工具如fiddler等，或者直接在浏览器控制台拿到模拟登陆所需要的参数的键值，后台拼接参数后向对应的路径发送请求，一般是post请求，就能正常模拟登陆成功了。 public void doLogin(@RequestParam(&quot;stuid&quot;)String stuid, @RequestParam(&quot;password&quot;)String password, @RequestParam(&quot;code&quot;) String code, HttpServletResponse response2) throws IOException { HttpPost post = new HttpPost(&quot;登陆的url&quot;); //装填参数 List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); nvps.add(new BasicNameValuePair(&quot;参数1&quot;,&quot;值1&quot;)); nvps.add(new BasicNameValuePair(&quot;参数1&quot;,&quot;值2&quot; )); post.setEntity(new UrlEncodedFormEntity(nvps, &quot;UTF-8&quot;)); post.setHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); post.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;); CloseableHttpResponse response = client.execute(post); response.close(); 难点模拟难点在于控制cookie的一致，或者说要保证获取验证码时的会话要跟提交参数登陆时的会话保持一致，这样保证验证码是正确的。代码中httpclicent对象最好是全局变量，这样会自动帮我们维持cookie的一致性（同一对象等价于同一个cookie)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First]]></title>
    <url>%2F2018%2F08%2F25%2FFirst%2F</url>
    <content type="text"><![CDATA[这是我的第一个博客，喜欢鼓捣很多东西]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
