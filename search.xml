<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java常见集合系列]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.java集合框架体系图 2.常见Map家族2.1 HashMap&nbsp;&nbsp;&nbsp;&nbsp;HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，HashMap最多只允许一条记录的键为null，允许多条记录的值为null。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&nbsp;&nbsp;&nbsp;&nbsp;HashMap的底层数据结构是数组+链表。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。其put方法的实现过程是，首先根据key的hashcode，进行高位运算，取模运算，并将结果作为数组下标，如果该位置已有值，则通过equals方法比较二者是否相等，如果相等则用新值覆盖旧值，如若不等，则将新建链表节点并插在已存节点的前面。同理，get方法的实现首先计算key的hashcode找到数组下标，通过equals方法比较链表中相等的键，然后返回该节点的value。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，put方法实现时可能存在扩容过程。因为Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。为了解resize机制，先看构造函数参数源码：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int threshold; //所能容纳的key-value对极限&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final float loadFactor; // 负载因子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int modCount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size;&nbsp;&nbsp;&nbsp;&nbsp;首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。&nbsp;&nbsp;&nbsp;&nbsp;结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择。&nbsp;&nbsp;&nbsp;&nbsp;size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。&nbsp;&nbsp;&nbsp;&nbsp;这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。 2.2 LinkedHashMap&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。在LinkedHashMap中，是通过双联表的结构来维护节点的顺序的，其他处理逻辑与HashMap一致，同样也没有锁保护，多线程使用存在风险。 2.3 TreeMap&nbsp;&nbsp;&nbsp;&nbsp;TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。底层是红黑树。 2.4 HashTable&nbsp;&nbsp;&nbsp;&nbsp;Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 3.常见List家族3.1 ArrayList&nbsp;&nbsp;&nbsp;&nbsp;ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。&nbsp;&nbsp;&nbsp;&nbsp;每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并 没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。ArrayList是非同步的（unsynchronized）。特点是：寻址容易，插入和删除困难； 3.2 LinkedList&nbsp;&nbsp;&nbsp;&nbsp;LinkedList实现了List接口，允许null元素，底层是一个链表。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。它也是非同步的。 3.3 Vector&nbsp;&nbsp;&nbsp;&nbsp;Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例 如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该 异常。 3.4 Stack&nbsp;&nbsp;&nbsp;&nbsp;Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得 Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 3.常见Set家族4.1 HashSet&nbsp;&nbsp;&nbsp;&nbsp;它不允许出现重复元素(根据hashCode比较)；&nbsp;&nbsp;&nbsp;&nbsp;不保证集合中元素的顺序&nbsp;&nbsp;&nbsp;&nbsp;允许包含值为null的元素，但最多只能有一个null元素。&nbsp;&nbsp;&nbsp;&nbsp;HashSet的实现是不同步的。&nbsp;&nbsp;&nbsp;&nbsp;HashSet的底层通过HashMap实现的。而HashMap在1.7之前使用的是数组+链表实现，在1.8+使用的数组+链表+红黑树实现。其实也可以这样理解，HashSet的底层实现和HashMap使用的是相同的方式，因为Map是无序的，因此HashSet也无法保证顺序。&nbsp;&nbsp;&nbsp;&nbsp;HashSet的方法，也是借助HashMap的方法来实现的。HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT = new Object();。 4.2 LinkedHashSet&nbsp;&nbsp;&nbsp;&nbsp;对于LinkedHashSet而言，它继承于HashSet、又基于LinkedHashMap来实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同。&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashSet是具有可预知迭代顺序的Set接口的哈希表和链接列表实现。此实现与HashSet的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。此实现不是同步的。 4.3 TreeSet&nbsp;&nbsp;&nbsp;&nbsp;TreeSet类实现 Set 接口，该接口由 TreeMap 实例支持。此类保证排序后的 set 按照升序排列元素，根据使用的构造方法不同，可能会按照元素的自然顺序 进行排序，或按照在创建 set 时所提供的比较器进行排序。&nbsp;&nbsp;&nbsp;&nbsp;TreeSet描述的是Set的一种变体——可以实现排序等功能的集合，它在将对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中.&nbsp;&nbsp;&nbsp;&nbsp;HashSet是基于Hash算法实现的,其性能通常优于TreeSet,我们通常都应该使用HashSet,在我们需要排序的功能时,我门才使用TreeSet;TreeSet是非同步的，线程不安全的。 4.4 HashSet，TreeSet，LinkedHashSet之间的区别&nbsp;&nbsp;&nbsp;&nbsp;HashSet只去重，TreeSet去重并排序，LinkedHashSet去重并保留插入顺序 5.List 、Set、 Map有什么区别和联系&nbsp;&nbsp;&nbsp;&nbsp;list 和set 有共同的父类 它们的用法也是一样的 唯一的不太就是set中不能有相同的元素 list中可以&nbsp;&nbsp;&nbsp;&nbsp;list和set的用途非常广泛 list可以完全代替数组来使用&nbsp;&nbsp;&nbsp;&nbsp;map 是独立的合集 它使用键值对的方式来储存数据 键不能有重复的 值可以用&nbsp;&nbsp;&nbsp;&nbsp;map不像上边两种集合那个用的广泛 不过在servlet 和jsp中map可是绝对的重中之重 页面之间传值全靠map]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[git基本命令]]></title>
    <url>%2F2019%2F03%2F06%2Fgit%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本地仓库基本操作工作区-暂存区-版本区创建本地仓库工作目录mkdir test 初始化本地仓库git init 在工作目录test里添加文件echo “first file” &gt;&gt; test.txt 将工作目录里的文件添加到暂存区git add test.txt 将暂存区里的文件提交到版本区git commit -m “first commit”删除回退操作修改了文件内容并add了文件,但尚未commit,回退到修改前git reset HEAD test.txtgit checkout – test.txt修改了文件内容并commit了文件，回退git loggit reset –hard “cid”清空本地仓库git rm test.txt 删了文件，暂存区还有记录git commit -m “delete” 提交删除，清空暂存区 远程仓库创建ssh keyssh-keygen -t rsa “yourmail@example.com“到用户目录下的.ssh 复制.pub到github构建ssh keyssh -T git@github.com 测试mkdir test2echo “test2” &gt;&gt; README.mdgit initgit add README.mdgit commit -m “test2”git remote add origin yourgithbub@name.gitgit push -u origin master(-u等于关联，后面可以直接git push)克隆仓库git clone yourgithub@name.gitcd nameecho “clone add file” &gt;&gt; test3.txtgit add test3.txtgit commit -m “clone”git push标签关联git taggit tag v1.0.1git tag -a name -m “comment”git push origin v1.0.1git tag -d name分支管理git branchgit branch namegit checkout nameecho “in branch” &gt;&gt; branch.txtgit add branch.txtgit commit -m “branch”git push –set-upstream origin namecheck out mastergit merge namegit branch -d namegit pullgit fetch]]></content>
  </entry>
  <entry>
    <title><![CDATA[JVM内存模型]]></title>
    <url>%2F2019%2F03%2F06%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.首先看个整体图 2.内存模型解释2.1.程序计数器&nbsp;&nbsp;&nbsp;&nbsp;当前线程所执行字节码的行号指示器，通过改变它的值来选取下一条指令。分支、循环、异常处理、线程恢复等都需要依赖它。它也是唯一一个不会抛出OutOfMemoryError异常的区域。 2.2.虚拟机栈(java栈)&nbsp;&nbsp;&nbsp;&nbsp;java栈描述java方法执行的内存模型。一个方法的执行时，会虚拟机会创建一个栈帧，存储局部变量表，操作数栈等。方法的调用到执行结束，相当于java栈的入栈出栈。该区域可能会产生两种异常。线程请求的栈的深度大于虚拟机允许的最大深度，抛出StackOverflowError。若该栈支持动态拓展（一般都支持），扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。 2.3.本地方法栈&nbsp;&nbsp;&nbsp;&nbsp;本地方法栈与java栈功能差不多，只是java栈为java程序方法服务，而它为本地方法服务。有的虚拟机（如sun HotSpot）甚至会把二者合二为一。 如java栈一样，该区域也会抛StackOverflowError、OutOfMemoryError异常。 2.4.JAVA堆&nbsp;&nbsp;&nbsp;&nbsp;对于大多数应用来说，java堆是虚拟机管理的内存中分配最大的一部分。java堆是被所有线程共享的一块内存区域。&nbsp;&nbsp;&nbsp;&nbsp;虚拟机启动时便创建。存放对象实例，几乎所有的对象实例都在这里分配内存。该区域也是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆。&nbsp;&nbsp;&nbsp;&nbsp;细分出来，该区域可以分为新生代，老年代，新生代可以再分为一个Eden空间，两个Survivor空间（from survivor，to survivor）。不论如何划分，存放的始终是实例对象。进一步划分的目的是利于回收内存，或者更快的分配内存。(内存收集器基本采用分代收集的方法)&nbsp;&nbsp;&nbsp;&nbsp;java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，且堆无法再拓展，将会抛出OutOfMemoryError异常。 2.5.方法区&nbsp;&nbsp;&nbsp;&nbsp;方法区与java堆一样，都是线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT)编译后的代码等数据。java虚拟机规范把方法区描述为java堆的一个逻辑部分，习惯在HotSpot虚拟机上开发的程序员更愿意称其为”永久代”。&nbsp;&nbsp;&nbsp;&nbsp;当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常。 2.6.运行时常量池&nbsp;&nbsp;&nbsp;&nbsp;运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后将进入方法区的运行时常量池中存放。&nbsp;&nbsp;&nbsp;&nbsp;作为方法区的一部分，运行时常量池受内存限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 3.一个对象的一辈子&nbsp;&nbsp;&nbsp;&nbsp;我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。 &nbsp;&nbsp;&nbsp;&nbsp;1、一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。&nbsp;&nbsp;&nbsp;&nbsp;2、并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。&nbsp;&nbsp;&nbsp;&nbsp;3、进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。&nbsp;&nbsp;&nbsp;&nbsp;分区的目的：新生区由于对象产生的比较多并且大都是朝生夕灭的，所以直接采用标记-清理算法。而养老区生命力很强，则采用复制算法，针对不同情况使用不同算法]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp开发过程中的乱码问题及其解决方案]]></title>
    <url>%2F2018%2F10%2F10%2Fjsp%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[jsp开发过程中的乱码问题及其解决方案1.必须先理清的关系jsp开发过程中,我们会看到page指令里有pageEncoding，contentType里的charset（后面一律简称charset),而浏览器自己也可以设置页面的编码格式。首先，pageEncoding表明，你这个文件将以什么编码形式保存起来。charset表明，你希望这里的代码以什么编码展示在浏览器上。浏览器自己也可以设置编码方式，当你的charset与浏览器不对应时就会出现乱码。 2.常见的几种编码 ISO-8895-1编码是单字节编码，因而可以达到数据无损,但不支持中文。 UTF-8编码多字节编码，支持中文等多种语言，是很通用的编码方式 gbk2312编码是针对中文而弄的一种编码 … 3.必须要知道的一些默认编码首先，get请求和post请求携带参数的方式不同（get直接在url上) 对于post请求，中文编码方式会受到上面提到的pageEncoding，charset，以及jsp内置对象request和response的setCharacterEncoding方法影响，后面会具体说明。 对于get请求，其中文编码会受到charset以及Tomcat服务器的配置信息影响，配置的是URLEncoding，在/conf/servlet.xml的文件中。据了解，Tomcat7及以下，默认采用ISO-8895-1,Tomcat8及以上采用UTF-8。 jsp中,request对象获取参数中需要特别注意到的一点是，对于get请求，采用request.getQueryString()得到的参数和用request.getParameter()得到的参数编码是不同的，因为方法getParameter()将会采用Tomcat服务器配置的URLEncoding自动解码一次,而getQueryString()会受到charset的影响 4.正式讲讲jsp中的编码问题 首先强调一点，内置对象的setCharacterEncoding只对post请求有效 对于post请求，当发送端用了response.setCharacterEncoding(Xxx),即设置了响应的编码格式，那么在服务器端，你可以选择用request.setCharacterEncoding(Xxx),即设置请求的编码方式来解决中文乱码问题。这一Xxx是必须一致的，response对应request。又或者，你可以自己手动转码的方式，把通过request.getParameter()得到的乱码数据data采用java.net.URLDecoder.decode(data, “Xxx”)或者new String(data.getBytes(“ISO-8895-1”),”Xxx”)从而解决乱码问题。当发送端没有设置response.setCharacterEncoding，那么此时需要参照contentType里的charset,这里的charset等价于上面的Xxx,依然可以用上述两种方式解决乱码问题。举个例子,A页面charset是utf-8，response.setCharacterEncoding是gbk2312，此时打开浏览器会是乱码，可以设置浏览器的编码为gbk，编码正常，而B页面charset也是utf-8，request.setCharacterEncoding必须是gbk，打印获取到的结果，在浏览器上还是乱码，因为浏览器在上一步被你设置成了gbk，换行utf-8正常。所以尽量控制charset与setCharacterEncoding是一致的 对于get请求，发送端的中文编码取决charset设置的编码方式，假如是utf-8，到了服务端的时候，若使用request.getParameter()，而此时你的Tomcat的URLEncoding是UTF-8,那么会自动用utf-8帮你解码一次，因而是不会出现乱码的情况。此时如果调用getQueryString(),打印的结果就是用charset设置utf-8编码方式编码的结果，需要手动解码回正常中文。 有一种无法挽回的特殊情况是，对于get请求，若发送端你的charset设置的是gbk2312，到了服务器端，假如你的Tomcat的URLEncoding是UTF-8，你用request.getParameter()获取参数，整个过程就等价于数据用了gbk2312编码，却用了utf-8自动解码，这样就会造成数据无法转回来了。当然此时你通过getQueryString()得到的数据通过解gbk2312码是可以得到正常结果的。 5.建议 控制contentType里的charset与pageEncoding与setCharacterEncoding()一致 对于中文数据尽量不用get请求提交，毕竟可能会造成上述说的无法挽回的结果。 可以设置拦截器，对请求统一进行编码，就不用一个页面调用设置编码的函数了]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jsp</tag>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈社团招新]]></title>
    <url>%2F2018%2F09%2F06%2F%E8%B0%88%E7%A4%BE%E5%9B%A2%E6%8B%9B%E6%96%B0%2F</url>
    <content type="text"><![CDATA[1 自从开学后，就开始准备招新事宜，我留任校团委网络中心，已经大三的我，不论当时留下来的原因是什么，如今尘埃落定，居其位,思其责，做其事。我其实很想逃避这些东西，但如今我逃避不了了。谈起招新，谈起扫楼，谈起跟其他组织竞争，可能有人会在背后说闲话，但我只能说，我只是在尽力做我能做的事情，没有恶意，我只是提供了一个选择，一个通往我部门的选择而已。但似乎，从其他人眼中，我所做的似有不妥。可能毕竟是竞争，可能我做的还不够好。 2我渐渐觉得社团是一个很迷的地方。如果一个人，坚持了一开始的想法，那么可能他就是体验社团一年，尝尝新鲜感，留下美好的回忆，然后大二离场。有的人，开始很融入这个社团，然后开始改变自己，改变想法，成功地走上了一条新的路，或者说被社团改造。我不能说这两种情况哪一个比较好，毕竟未来谁能预料地到。社团这条路，一开始，一群人挤着抢着上车，司机也各显神通地邀请，然而讽刺的是，到最后，幸运的人成功的进入了社团，可怜的人，从被抢来抢去，到被抛来抛去，最后再也鼓不起勇气去报其他。而更讽刺的是，某些幸运的人没有做出他应该做到的表现，而当时如果招入的是其他人，结局也又未可知。这时，我们往往会说，这就是命，或者说，缘分使然，感怀亦是徒然。 3不知为何，我开始会想很多东西，考虑很多东西，我开始担心自己做的不够好，我甚至害怕带不起他们。我开始为这些事操心，明明，我应该大胆放手，让他们成长。我似乎很自卑，但在一部分人眼中，我好像也很“完美”。我感觉我变了，我开始想写一些感受，我的话开始变的很多。 4我的大学只选择了一个社团，可能我是无法体会到那些报了多个社团的人的感受，我甚至都无法去评论，因为那样显得很片面。而有的人也是只选择了一个社团，但是他却也局限于只了解这一社团，似有井底之蛙之嫌。谈到社团，却又不得不提归属感一词，有的人愿意为部门付出很多，而且无怨无悔，甚至乐此不疲，而有的人唯恐避之不及。有的人只想得到什么，不打算去付出。我不知道每一个他们是怎么想的，我也不知道他们是否认真考虑过它的意义。或许是我的成长环境决定了我的所思所想，在外人看来觉得完全没有必要去做某些我认为才是真正该做该学的事。但想回来，我应该是个利己主义者，但为何偏偏去替他人担忧他的未来。是因为他们过的比我洒脱，我需要自我安慰自己？我想有部分原因是这样的。可是明明，我对自己的未来都没能把控好，但何苦去评判他人。这一点，我不知道为什么，或者说，我还没能想到这一层。 5走走停停，大学就这么过去了，可能毕业后的自己，回想如今，又是千思百绪，又或者嘲笑自己。甚至于说，多年之后，我才记起，我在大三的招新工作里，写了这么一篇文章。如果现在的我，无意间翻到了初中时的我写的东西，多么稚嫩，却也很美好。]]></content>
      <categories>
        <category>我说</category>
      </categories>
      <tags>
        <tag>生活闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http模拟登陆]]></title>
    <url>%2F2018%2F09%2F03%2Fhttp%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[使用java作为后台语言，实现带验证码的模拟登陆。采用springboot快速开发。简单而言，过程分两步 一、获取验证码图片通过抓包工具如fiddler等，或者直接在浏览器控制台找到获取验证码图片的url。然后后台发起http请求，拿到图片并展示。 如下获取验证码图片函数 private void getImg(HttpServletResponse response){ HttpGet get = new HttpGet(&quot;验证码的url&quot;); try { CloseableHttpResponse res = client.execute(get); HttpEntity entity = res.getEntity(); OutputStream out = response.getOutputStream(); byte[] buffer = new byte[1024]; int end; while ((end=entity.getContent().read(buffer))!=-1){ out.write(buffer); } out.close(); response.setContentType(&quot;image/jpeg&quot;);//设置相应类型,告诉浏览器输出的内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);//设置响应头信息，告诉浏览器不要缓存此内容 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); // 将内存中的图片通过流动形式输出到客户端 } catch (IOException e) { e.printStackTrace(); } 二、模拟登陆通过抓包工具如fiddler等，或者直接在浏览器控制台拿到模拟登陆所需要的参数的键值，后台拼接参数后向对应的路径发送请求，一般是post请求，就能正常模拟登陆成功了。 public void doLogin(@RequestParam(&quot;stuid&quot;)String stuid, @RequestParam(&quot;password&quot;)String password, @RequestParam(&quot;code&quot;) String code, HttpServletResponse response2) throws IOException { HttpPost post = new HttpPost(&quot;登陆的url&quot;); //装填参数 List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); nvps.add(new BasicNameValuePair(&quot;参数1&quot;,&quot;值1&quot;)); nvps.add(new BasicNameValuePair(&quot;参数1&quot;,&quot;值2&quot; )); post.setEntity(new UrlEncodedFormEntity(nvps, &quot;UTF-8&quot;)); post.setHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); post.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;); CloseableHttpResponse response = client.execute(post); response.close(); 难点模拟难点在于控制cookie的一致，或者说要保证获取验证码时的会话要跟提交参数登陆时的会话保持一致，这样保证验证码是正确的。代码中httpclicent对象最好是全局变量，这样会自动帮我们维持cookie的一致性（同一对象等价于同一个cookie)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First]]></title>
    <url>%2F2018%2F08%2F25%2FFirst%2F</url>
    <content type="text"><![CDATA[这是我的第一个博客，喜欢鼓捣很多东西]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
