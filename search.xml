<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搭建高可用高并发系统]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[高可用高并发系统设计架构设计三大定律墨菲定律 任何事没有表面看起来那么简单所有的事都会比预计的时间长 - 可能出错的事情总会出错 - 担心某种事情发生，那么它就更有可能发生 康威定律 系统架构师公司组织架构的反映按照业务闭环进行系统拆分/组织架构划分，实现闭环、高内聚、低耦合，减少沟通成本如果沟通出现问题，应该考虑进行系统和组织架构的调整 适合时机进行系统拆分。不要一开始就吧系统、服务拆分拆的非常细，虽然闭环，但是每个人维护的系统多，维护成本高 - 微服务架构的理论基础 - 康威定律 二八定律 80%的结果取决于20%的原因 高可用所谓高可用，即要保证系统在几乎任何时候都能正常运行，功能正常，保证系统不出问题，“永不宕机”。 1.单机系统下的可用性问题，从Nginx-&gt;Tomcat-&gt;db/soa来看，单点问题会影响系统的高可用。比如要是这个链路上其中一个单点挂了，整个系统就不可以用了。（Nginx负载均衡等，Tomcat提供服务，db存储数据）。所以引申 2.出来主备/集群模式，防止单点问题。高并发场景下，请求过多也会因为后端瓶颈点引起整个系统down掉，如周杰伦演唱会抢票，高铁抢票，所以一般情况下对并发场景我们会限流，采用mq等消息队列形式削峰，保证后端系统不会down掉。 设计建议1.减少单点去去单点首先要识别出整个系统所有主链路的单点，如机房（同城异地双机房）、应用服务器、DNS服务器、SFTP服务器、LBS（基于位置服务）缓存服务器、数据库、消息服务器、代理服务器和专线等。如系统通过专线调用对方服务，需要考虑同时拉联通和电信的专线，联通或电信的专线还是有一定效率出现问题但是同时出现问题的概率就会小很多。优先使用软负载（负载软件如Nginx），使用硬负载（外部网络和服务器间的硬件设备如F5）兜底。 2.减少依赖减少DNS依赖，减少远程服务依赖。DNS依赖可以尝试设置本地host，用工具给所有服务器推送最新的域名映射关系，通过本地缓存或者近端服务减少RPC（远程过程调用）调用。 3.限制循环避免无限死循环，导致CPU利用率百分百，可以设置for循环的最大循环次数，如最大1000次 4.增加限流对外服务增加限流，注意限流的值最好是压测过的，如果没有压测过，只能设置成平时的峰值流量，否则可能增加一点流量就不能提供服务了。 5.控制流量避免异常流量对应用服务器产生影响，可以对指定指定服务设置流量限制，如QPS(每秒查询率),TPS(每秒处理事务数),QPH(每小时总请求量),QPD(每天总请求量) 6.精准监控对CPU利用率，load，内存，带框，系统调用量，应用错误量，PV(页面浏览量),UV(独立访客量，以cookie为主)和业务进行监控，避免内存泄露和异常代码对系统产生影响，配置一定要精准，如平时设置内存利用率是50%，监控可以配置成60%进行报警，这样可以提前感知内存泄露问题，避免应用无响应。 7.无状态服务器不能保存用户状态数据，如在集群下不能用static保存用户数据，不能长时间把用户文件存放在服务器本地。服务器有状态会难以扩容，出现单点问题。 8.容量规划定期对容量进行评估，如大促前进行压测和容量预估，根据需要进行扩容。如双11进行扩容。 9.功能开关打开和关闭某些功能，如消息量过大，系统处理不了，把开关打开后直接丢弃信息不处理。上线新功能增加开关，如果出现问题就关闭新功能。 10.设置超时设置连接超时和读超时设置，不应该太大，如果是内部调用连接超时可以设置成1秒，读超时3秒，外部系统调用连接超时可以设置成3秒，读超时设置20秒。 11.重试策略当调用外部服务异常时可以设置重试策略，每次重试时间递增，但需要设置最大重试次数和重试开关，避免对下游系统产生影响。 12.隔离应用隔离，模块隔离，机房隔离，线程池隔离。按照优先级，不变和变几个维度来隔离应用和模块，如抽象和不变的代码放在一个模块，这个模块的代码几乎不会修改，可用性高，经常变的业务逻辑放在一个模块里，这样就算出现问题，也只影响某一业务。不同业务使用不同的线程池，避免低先级任务阻塞高优先级，或者高优先级任务过多影响低优先级任务永不执行。 13.异步调用同步调用变成异步调用，解决远程调用障碍或者调用超时对系统的影响。 14.热点缓存对热点数据进行缓存，降低RPC调用。如B系统提供名单服务，B系统可以提供一个client SDK提供近端缓存服务，定期去服务器读取数据，减少RPC调用。 15.缓存容灾当数据库不可用时可以使用缓存的数据。并设置分级缓存，如优先读取本地缓存，其次分布式缓存。 16.分级缓存优先读取本地缓存，其次读取分布式缓存。通过推模式更新本地缓存。 17.系统分级对系统进行分级，如ABC三个等级，高级别系统不依赖与低级别系统，并且高级别系统比低级别系统高可用虑高 18.服务降级如果系统出现响应缓慢等状况，可以关闭部分功能，从而释放系统资源，保证核心服务的正常运行。需要识别哪些服务可以降级，比如突然有大量消息流入，导致服务不可用，我们会直接把消息丢掉。或者设置流控，拒绝为低级别系统提供服务。 19.流量蓄洪当流量陡增时，可以将请求进行蓄洪，如把请求保存在数据库中，再按照指定的QPS进行泄洪，有效保护下游系统，也保证了服务的可用性。调用对方系统，对方系统缓慢或者无响应时，可采取自动蓄洪。 20.服务权重在集群环境中，可自动识别高性能服务，拒绝调用性能低的服务，如在集群环境中，对调用超时的服务器进行权重降低，优先调用权重高的服务器。 21.依赖简化减少系统间的依赖，如使用消息驱动。A和B系统通过消息服务器传递数据，A和B系统使用数据库进行读写分离，A系统负责往数据库写数据，B系统负责读数据，因为数据存放在数据库中，当A不可用时，短时间不影响B系统提供服务。 22.弹性扩容根据资源的使用率自动或者手动进行扩容。如带宽不够用，快速增加带宽。 23.灰度和回滚发布新功能只让部分服务器生效，且观察几天逐渐切流，如果出现问题只影响部分客户。出现问题快速回滚，或者直接下线灰度的机器。 24.减少远程调用优先调用本地JVM内服务，其次是同机房服务，然后是同城服务，最后是跨城服务。如A调用B，B调用互联网C的系统获取数据，B系统可以把数据缓存起来，并设置数据的保鲜度，减少B对C的依赖。配置中心把注册服务的地址推送到调用服务的系统本地。参数中心把参数配置信息推送到系统的本地内存，而不是让系统去远程服务器获取参数信息。 25.熔断机制增加熔断机制，当监控出现数据大幅涨跌时，及时中断，避免对业务产生更大影响。如我们做指标计算时，指标可以计算慢，但不能算错，如果发现某个用户的指标环比或同比增长一倍或跌零，会考虑保存所有信息，并终止该用户的指标计算。 26.运行时加载模块我们会把经常变的业务代码变成一个个业务模块，使用JAVA的ClassLoader在运行时动态加载和卸载模块，当模块有问题时，可以快速修复。 27.代码扫描#使用IDEA代码分析等工具进行代码扫描，识别出程序中的BUG,如空指针异常，循环依赖。 28.自动备份程序，系统配置和数据定期进行备份。可以使用Linux命令和shell脚本定时执行备份策略，自动进行本地或者异地备份。出现问题时能快速重新部署。 29.线上测压系统的对外服务需要进行压测，知道该服务承受的QPS和TPS,从而做出相对精准的限流。 高并发所谓高并发，即能够同时接受处理千万级乃至亿万级的并发访问。 高并发又分为cpu密集型和io密集型。前者要求网站的计算能力要高，后者要求网站的吞吐能力要高。 高并发设计有几个原则如下:1.无状态无状态应用，便于水平扩展 有状态配置可通过配置中心实现无状态 实践: Disconf、Yaconf、Zookpeer、Consul、Confd、Diamond、Xdiamond等 2.拆分系统维度：按照系统功能、业务拆分，如购物车，结算，订单等 功能维度：对系统功能在做细粒度拆分 读写维度：根据读写比例特征拆分；读多，可考虑多级缓存；写多，可考虑分库分表 AOP维度： 根据访问特征，按照AOP进行拆分，比如商品详情页可分为CDN、页面渲染系统，CDN就是一个AOP系统 模块维度：对整体代码结构划分Web、Service、DAO 3.服务化服务化演进: 进程内服务-单机远程服务-集群手动注册服务-自动注册和发现服务-服务的分组、隔离、路由-服务治理 考虑服务分组、隔离、限流、黑白名单、超时、重试机制、路由、故障补偿等 实践：利用Nginx、HaProxy、LVS等实现负载均衡，ZooKeeper、Consul等实现自动注册和发现服 4.消息队列目的: 服务解耦(一对多消费)、异步处理、流量削峰缓冲等 大流量缓冲： 牺牲强一致性，保证最终一致性 (案例：库存扣减，现在Redis中做扣减，记录扣减日志，通过后台进程将扣减日志应用到DB) 数据校对: 解决异步消息机制下消息丢失问题 5.数据异构数据异构: 通过消息队列机制接收数据变更，原子化存储 数据闭环: 屏蔽多从数据来源，将数据异构存储，形成闭环 6.缓存用户层: DNS缓存 浏览器DNS缓存 操作系统DNS缓存 本地DNS服务商缓存 DNS服务器缓存 客户端缓存 浏览器缓存(Expires、Cache-Control、Last-Modified、Etag) App客户缓存(js/css/image...) 代理层： CDN缓存(一般基于ATS、Varnish、Nginx、Squid等构建,边缘节点-二级节点-中心节点-源站) 接入层： Opcache： 缓存PHP的Opcodes Proxy_cache： 代理缓存,可以存储到/dev/shm或者SSD FastCGI Cache Nginx+Lua+Redis: 业务数据缓存 应用层： 页面静态化 业务数据缓存(Redis/Memcached/本地文件等) 消息队列 数据层： NoSQL： Redis、Memcache、SSDB等 MySQL： Innodb/MyISAM等Query Cache、Key Cache、Innodb Buffer Size等 系统层： CPU : L1/L2/L3 Cache/NUMA 内存 磁盘：磁盘本身缓存、dirtyratio/dirtybackground_ratio、阵列卡本身缓存]]></content>
      <categories>
        <category>设计理论</category>
      </categories>
      <tags>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA中的相等比较]]></title>
    <url>%2F2019%2F08%2F16%2FJAVA%E4%B8%AD%E7%9A%84%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[1、 == java中的数据类型，可分为两类: 1.基本数据类型，也称原始数据类型 byte、short、char、int、long、float、double、boolean，他们之间的比较 使用==时，比较的是他们的值 2.引用类型（类、接口、数组） 当他们使用==比较的时候，比较的是内存中存放的地址，所以，除非是同一个new出来的对象，他们比较结果为true，否则为false 当基本数据类型与其对应的对象比较时如，int和Integer进行比较时，Integer会自动拆箱为int，进行值的比较。 对象存放在堆中，栈中存放着对象的引用（地址）。由此可见，== 比较的是栈中的值进行比较。如果要比较两个对象的内容是否相等，那么就要重写equal方法了。 public static void main(String[] args) { int int1 = 12; int int2 = 12; Integer Integer1 = new Integer(12); Integer Integer2 = new Integer(12); Integer Integer3 = new Integer(127); Integer a1 = 127; Integer b1 = 127; Integer a = 128; Integer b = 128; String s1 = &quot;str&quot;; String s2 = &quot;str&quot;; String str1 = new String(&quot;str&quot;); String str2 = new String(&quot;str&quot;); System.out.println(&quot;int1==int2:&quot; + (int1 == int2)); System.out.println(&quot;int1==Integer1:&quot; + (int1 == Integer1)); System.out.println(&quot;Integer1==Integer2:&quot; + (Integer1 == Integer2)); System.out.println(&quot;Integer3==b1:&quot; + (Integer3 == b1)); System.out.println(&quot;a1==b1:&quot; + (a1 == b1)); System.out.println(&quot;a==b:&quot; + (a == b)); System.out.println(&quot;s1==s2:&quot; + (s1 == s2)); System.out.println(&quot;s1==str1:&quot; + (s1 == str1)); System.out.println(&quot;str1==str2:&quot; + (str1 == str2)); } 输出结果： int1==int2:true int1==Integer1:true //Integer会自动拆箱为int，所以为true Integer1==Integer2:false//不同对象，在内存存放地址不同，所以为false Integer3==b1:false//Integer3指向new的对象地址，b1指向缓存中127地址，地址不同，所以为false a1==b1:true a==b:false s1==s2:true s1==str1:false str1==str2:false ！！！敲黑板 Integer b1 = 127;java在编译的时候,被翻译成-&gt; Integer b1 = Integer.valueOf(127); 而该方法源码: public static Integer valueOf(int i) { assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 所以，对应-128-127之间的数，会进行缓存，Integer b1 = 127时，会将127进行缓存，下次再写Integer i6 = 127时，就会直接从缓存中取，就不会new了。而b的值是128，因此不会有缓存。所以a1==b1:true a==b:false 2、 equals 1.默认情况下（即equals方法未被覆盖）equals方法都是调用Object类的equals方法，，而Object的equals方法主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。下面是Object类中equals方法： public boolean equals(Object obj) { return (this == obj); } 所以此时，equals方法与==本质上是一样的 2.若类的equals方法被覆盖，则比较时根据代码实现的规则比较，一般都是比较对象内容是否相等。下面是String类equals方法的覆盖: public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = count; if (n == anotherString.count) { char v1[] = value; char v2[] = anotherString.value; int i = offset; int j = anotherString.offset; while (n– != 0) { if (v1[i++] != v2[j++]) return false; } return true; } } return false; } 即String中equals方法判断相等的步骤是： 1.若A==B 即是同一个String对象 返回true 2.若对比对象是String类型则继续，否则返回false 3.判断A、B长度是否一样，不一样的话返回false 4。逐个字符比较，若有不相等字符，返回false ！！！敲黑板 equals方法的覆盖需要注意5点 1 自反性：对任意引用值X，x.equals(x)的返回值一定为true. 2 对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true; 3 传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true 4 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变 5 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 参照5个注意点，写出高质量的equals方法可以参考以下方式: 1.使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。 2.使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。 3.把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。 4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。 5.当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。 3、hashcode hashCode()方法返回的是一个数值，即hash码。它的主要用途是在对象进行散列的时候作为key输入。Object类提供的默认实现确保每个对象的hash码不同(在对象的内存地址基础上用特殊算法得出). 所有散列函数都有一个基本特征: 1.如果a=b，则h(a)=h(b) 2.如果a！=b 则h(a)和h(b)有可能得到相同的散列值 Object 的hashCode方法：返回一个int类型 哈希值的作用 举例来说,java集合中Set无序不重复，那么就存在一个问题，如何保证元素不重复。调用Obejct.equals方法可以判断两个元素是否相等。但是，如果使用顺序查找，当元素很多时，查找的复杂度就会变大。如，set已有1000元素，新增元素时最坏需要调用1000次equal方法确定是否已经存在。但是，当使用哈希表的时候，新增元素，计算该元素的hash值，从哈希表中看以该值为下标是否存在元素，即可判断重复与否。当然也存在哈希冲突解决问题。但大大减少了equal调用次数 4、equals和hashCode的关系 Java对于eqauls方法和hashCode方法是这样规定的： (1)同一对象上多次调用hashCode()方法，总是返回相同的整型值。 (2)如果a.equals(b)，则一定有a.hashCode() 一定等于 b.hashCode()。 (3)如果!a.equals(b)，则a.hashCode() 不一定等于 b.hashCode()。此时如果a.hashCode() 总是不等于 b.hashCode()，会提高hashtables的性能。 (4)a.hashCode()==b.hashCode() 则 a.equals(b)可真可假 (5)a.hashCode()！= b.hashCode() 则 a.equals(b)为假。 简而言之就是: 1、两个对象equal，java环境会认为hashcode一定相等 2、两个对象不equal，二者hashcode可能相等 反过来说 1、两个对象hashcode相等，不一定equal 2、两个对象hashcode不等，一等不equal ！！！敲黑板 关于这两个方法的重要规范： 规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。 规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。 5、为什么覆盖equals方法时总要覆盖hashCode 一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。 1.在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。 2.如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。 3.如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java常见集合系列]]></title>
    <url>%2F2019%2F03%2F07%2Fjava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[1.java集合框架体系图 2.常见Map家族2.1 HashMap&nbsp;&nbsp;&nbsp;&nbsp;HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，HashMap最多只允许一条记录的键为null，允许多条记录的值为null。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。&nbsp;&nbsp;&nbsp;&nbsp;HashMap的底层数据结构是数组+链表。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。其put方法的实现过程是，首先根据key的hashcode，进行高位运算，取模运算，并将结果作为数组下标，如果该位置已有值，则通过equals方法比较二者是否相等，如果相等则用新值覆盖旧值，如若不等，则将新建链表节点并插在已存节点的前面。同理，get方法的实现首先计算key的hashcode找到数组下标，通过equals方法比较链表中相等的键，然后返回该节点的value。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，put方法实现时可能存在扩容过程。因为Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。为了解resize机制，先看构造函数参数源码：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int threshold; //所能容纳的key-value对极限&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final float loadFactor; // 负载因子&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int modCount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int size;&nbsp;&nbsp;&nbsp;&nbsp;首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。&nbsp;&nbsp;&nbsp;&nbsp;结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择。&nbsp;&nbsp;&nbsp;&nbsp;size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。&nbsp;&nbsp;&nbsp;&nbsp;这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。 2.2 LinkedHashMap&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。在LinkedHashMap中，是通过双联表的结构来维护节点的顺序的，其他处理逻辑与HashMap一致，同样也没有锁保护，多线程使用存在风险。 2.3 TreeMap&nbsp;&nbsp;&nbsp;&nbsp;TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。底层是红黑树。 2.4 HashTable&nbsp;&nbsp;&nbsp;&nbsp;Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 3.常见List家族3.1 ArrayList&nbsp;&nbsp;&nbsp;&nbsp;ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。&nbsp;&nbsp;&nbsp;&nbsp;每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并 没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。ArrayList是非同步的（unsynchronized）。特点是：寻址容易，插入和删除困难； 3.2 LinkedList&nbsp;&nbsp;&nbsp;&nbsp;LinkedList实现了List接口，允许null元素，底层是一个链表。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。它也是非同步的。 3.3 Vector&nbsp;&nbsp;&nbsp;&nbsp;Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的 Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例 如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该 异常。 3.4 Stack&nbsp;&nbsp;&nbsp;&nbsp;Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得 Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 3.常见Set家族4.1 HashSet&nbsp;&nbsp;&nbsp;&nbsp;它不允许出现重复元素(根据hashCode比较)；&nbsp;&nbsp;&nbsp;&nbsp;不保证集合中元素的顺序&nbsp;&nbsp;&nbsp;&nbsp;允许包含值为null的元素，但最多只能有一个null元素。&nbsp;&nbsp;&nbsp;&nbsp;HashSet的实现是不同步的。&nbsp;&nbsp;&nbsp;&nbsp;HashSet的底层通过HashMap实现的。而HashMap在1.7之前使用的是数组+链表实现，在1.8+使用的数组+链表+红黑树实现。其实也可以这样理解，HashSet的底层实现和HashMap使用的是相同的方式，因为Map是无序的，因此HashSet也无法保证顺序。&nbsp;&nbsp;&nbsp;&nbsp;HashSet的方法，也是借助HashMap的方法来实现的。HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT = new Object();。 4.2 LinkedHashSet&nbsp;&nbsp;&nbsp;&nbsp;对于LinkedHashSet而言，它继承于HashSet、又基于LinkedHashMap来实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同。&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashSet是具有可预知迭代顺序的Set接口的哈希表和链接列表实现。此实现与HashSet的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。此实现不是同步的。 4.3 TreeSet&nbsp;&nbsp;&nbsp;&nbsp;TreeSet类实现 Set 接口，该接口由 TreeMap 实例支持。此类保证排序后的 set 按照升序排列元素，根据使用的构造方法不同，可能会按照元素的自然顺序 进行排序，或按照在创建 set 时所提供的比较器进行排序。&nbsp;&nbsp;&nbsp;&nbsp;TreeSet描述的是Set的一种变体——可以实现排序等功能的集合，它在将对象元素添加到集合中时会自动按照某种比较规则将其插入到有序的对象序列中.&nbsp;&nbsp;&nbsp;&nbsp;HashSet是基于Hash算法实现的,其性能通常优于TreeSet,我们通常都应该使用HashSet,在我们需要排序的功能时,我门才使用TreeSet;TreeSet是非同步的，线程不安全的。 4.4 HashSet，TreeSet，LinkedHashSet之间的区别&nbsp;&nbsp;&nbsp;&nbsp;HashSet只去重，TreeSet去重并排序，LinkedHashSet去重并保留插入顺序 5.List 、Set、 Map有什么区别和联系&nbsp;&nbsp;&nbsp;&nbsp;list 和set 有共同的父类 它们的用法也是一样的 唯一的不太就是set中不能有相同的元素 list中可以&nbsp;&nbsp;&nbsp;&nbsp;list和set的用途非常广泛 list可以完全代替数组来使用&nbsp;&nbsp;&nbsp;&nbsp;map 是独立的合集 它使用键值对的方式来储存数据 键不能有重复的 值可以用&nbsp;&nbsp;&nbsp;&nbsp;map不像上边两种集合那个用的广泛 不过在servlet 和jsp中map可是绝对的重中之重 页面之间传值全靠map]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典排序算法]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法是最经典的算法知识。因为其实现代码短，应该广，在面试中经常会问到排序算法及其相关的问题。一般在面试中最常考的是快速排序和归并排序等基本的排序算法，并且经常要求现场手写基本的排序算法。如果这些问题回答不好，估计面试就凉凉了。所以熟练掌握排序算法思想及其特点并能够熟练地手写代码至关重要。 下面介绍几种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、基数排序的思想，其代码均采用Java实现。 1.冒泡排序1.1.思想 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端 1.2.算法描述比较相邻的元素。如果第一个比第二个大，就交换它们两个；对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；针对所有的元素重复以上的步骤，除了最后一个；重复步骤1~3，直到排序完成 1.3.动画演示 1.4.代码实现public static int[] bubble(int[] a){ int temp = 0; for (int i=0;i&lt;a.length;i++){//遍历整个数组 for (int j=0;j&lt;a.length-1-i;j++){//每次遍历跟相邻比较 if (a[j]&gt;a[j+1]){ //把大的值往后放 temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } }//一次循环后就能把最大值（最小值）浮动到数组尾（头） } return a; } 2.选择排序2.1 思想选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。 2.2算法描述在未排序序列中找到最小（大）元素，存放到排序序列的起始位置从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。 2.3.动画演示 2.4.代码实现 public static int[] select(int[] array){ int temp = 0; for (int i=0;i&lt;array.length;i++){ for (int j=i+1;j&lt;array.length;j++){//每次当前值都和后面所有值比较，找到比它小的就交换 if (array[i]&gt;array[j]){ temp = array[i]; array[i] = array[j]; array[j] = temp; } }//每次循环结束，就能找到相对最小值放在数组起那么 } return array; } //改进选择排序，记录最小值下标，只交换一次 public static int[] select2(int[] array){ int temp = 0; for (int i=0;i&lt;array.length;i++){ int minIndex = i; //记录下标值 for (int j=i+1;j&lt;array.length;j++){ if (array[minIndex]&gt;array[j]){ minIndex = j; } } temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; } return array; } 3.插入排序3.1.思想插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.2.算法描述把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。重复上述过程直到最后一个元素被插入有序子数组中。 3.3.动画演示 3.4.代码实现//直插，总是假设前面是有序的，后面往前找到合适的位置插入 public static int[] insert(int[] a,int n){ int temp = 0 ; int j; for (int i=0;i&lt;n;i++){//遍历全部 temp = a[i+1]; //暂存当前的下一个 j=i; //j从当前开始 while (j&gt;-1&amp;&amp;temp&lt;a[j]){//如果后面的值小于当前值，进入循环 a[j+1] = a[j]; //temp已经存了下一个的值，可以直接覆盖 j--; } a[j+1] = temp; //恢复覆盖的值 } return a; } 4.归并排序4.1.思想归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 4.2.算法描述迭代法（Bottom-up）原理如下（假设序列共有n个元素）： 将序列每相邻两个数字进行归并操作，形成ceil(n/2)个序列，排序后每个序列包含两/一个元素若此时序列数不是1个则将上述序列再次归并，形成ceil(n/4)个序列，每个序列包含四/三个元素重复步骤2，直到所有元素排序完毕，即序列数为1 4.3.动画演示 4.4.代码实现//归并，借助辅助交换数组,根据k长度进行归并 public static int[] merge(int[] a,int k){//k是分组的长度 int aLeft = 0; //第分组起始下标 int aRight; //a分组终止下标 int bLeft; //b分组起始下标 int bRight; //第分组终止下标 int[] swap = new int[a.length];//等长辅助数组 int m = 0; //m记录辅助数组下标位置 int i,j; //i记录a分组遍历，b记录b分组遍历 while (aLeft+k&lt;=a.length-1){//从相邻分组b起始遍历，将b往a里合并 bLeft = aLeft+k; //b分组的起始下标=第1分组起始+分组长度 aRight = bLeft-1; //a分组的终止是b分组起始往前退1 bRight = (bLeft+k&gt;a.length)? a.length-1:bLeft+k-1;//b分组=b起始+长度，但是不能超高a数组总长度 for (i=aLeft,j=bLeft;i&lt;=aRight&amp;&amp;j&lt;=bRight;m++){//从a分组开始扫描比较 if (a[j]&gt;=a[i]){//如果a分组小，放入辅助数组，a分组前进 swap[m] = a[i]; i++; }else {//如果b分组小，放入辅助数组，b分组前进 swap[m] = a[j]; j++; } } //遍历结束，一定至少有一个分组已经合并完 while (i&lt;=aRight){//如果a分组还没合并完 swap[m++] = a[i++]; //剩余数据压入辅助数组 } while (j&lt;=bRight){//如果b分组还没合并完 swap[m++] = a[j++]; } aLeft = bRight+1;//a,b合并完后下一个新a分组从旧b分组长度+1开始 } //此时所有能完整分组的已经合并完，剩下分组长度不足数的 for (i=aLeft;i&lt;a.length;i++){//从不足数分组起始遍历 swap[m++] = a[i]; //全部压入辅助数组中 } return swap; } //合并长度长1，2,2k... public static int[] mergeSort(int[] a){ int i,k=1; while (k&lt;a.length){ a = merge(a,k ); k = 2*k; } return a; } 5.快速排序5.1.思想快速排序是一个知名度极高的排序算法，其对于大数据的优秀排序性能和相同复杂度算法中相对简单的实现使它注定得到比其他算法更多的宠爱。 5.2.算法描述从数列中挑出一个元素，称为”基准”（pivot），重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 5.3.动画演示 5.4代码实现//快排,从第一个元素开始，比他小的在左边，比他大的在右边，递归左右 public static int[] quick(int[] a,int left,int right){ int temp = a[left];//总是从最左第一个 int i = left; int j = right; while (i&lt;j){ while (i&lt;j&amp;&amp;temp&lt;=a[j]){//从右到左，找第一个比它小的 j--; } if (i&lt;j){//如果找到了 a[i] = a[j];//将比它大的值移到最右左边 i++; //左边距离前进一个单位 } while (i&lt;j&amp;&amp;a[i]&lt;temp){//从左向右，找第一个比它大的 i++; } if (i&lt;j){//如果找到了 a[j] = a[i];//将比他小的移到右边 j--; //右边距离缩短一个单位 } a[i] = temp; //找到了合适的位置放进去，左边都比它小，右边都比它大 } if (i&gt;left)quick(a,left ,i-1 );//递归左边的子集 if (i&lt;right)quick(a,j+1 ,right );//递归右边的子集 return a; } 6.堆排序6.1.思想堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。 6.1.1.堆概念堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。如下图，是一个堆和数组的相互关系：对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标： Parent(i) = floor(i/2)，i 的父节点下标Left(i) = 2i，i 的左子节点下标Right(i) = 2i + 1，i 的右子节点下标二叉堆一般分为两种：最大堆和最小堆。最大堆中的最大元素值出现在根结点（堆顶）堆中每个父节点的元素值都大于等于其孩子结点（如果存在）最小堆中的最小元素值出现在根结点（堆顶）堆中每个父节点的元素值都小于等于其孩子结点（如果存在） 6.2.算法描述堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作： 最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变 6.3.动画演示6.4代码实现//堆排序(最大堆) public static int[] heap(int[] a){ int temp = 0; initHeap(a,a.length ); //2.1初始化堆，将无序序列构造为堆。 for (int i=a.length-1;i&gt;0;i--){ temp = a[0]; //2.2 弹出堆顶 a[0] = a[i]; a[i] = temp; //将最大值放入数组尾 createHeap(a, 0,i );//2.3,缩小建堆范围，重新构建堆 } return a; } //从第一个非叶子节点开始建堆 public static int[] initHeap(int[] a,int n){ for (int i= (a.length-2)/2;i&gt;=0;i--){ a = createHeap(a,i,a.length); } return a; } //以h为建堆顶点,建立并调整堆 public static int[] createHeap(int[] a,int h,int n){ int i,j,tag;//tag循环结束条件（调整节点比左右都大直接出来） i = h; // i是要建堆的节点下标 j=2*i+1; //建堆节点的左孩子 int temp = a[i]; tag = 0; while (j&lt;n&amp;&amp;tag!=1){ if (j&lt;n-1&amp;&amp;a[j]&lt;a[j+1])j++;//比较左右，取大值 if (temp&gt;a[j]){ tag = 1; }else {//调整建堆顶点，向下调整 a[i] = a[j]; i = j; j = 2*i+1; } } a[i] = temp; return a; } 7.希尔排序7.1.思想在希尔排序出现之前，计算机界普遍存在“排序算法不可能突破O(n2)”的观点。希尔排序是第一个突破O(n2)的排序算法，它是简单插入排序的改进版。希尔排序的提出，主要基于以下两点：插入排序算法在数组基本有序的情况下，可以近似达到O(n)复杂度，效率极高。但插入排序每次只能将数据移动一位，在数组较大且基本无序的情况下性能会迅速恶化。 7.2.算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；按增量序列个数k，对序列进行 k 趟排序；每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 7.3.动画演示 7.4代码实现//希尔，把数组按步长分组，每组分别进行直插排序 public static int[] shell(int[]a,int[] spans){ int span; for (int i=0;i&lt;spans.length;i++){//遍历希尔步长次 span = spans[i]; for (int k=0;k&lt;span;k++){//全部数据按照步长分组 for (int j=k;j+span&lt;a.length;j+=span){//对每个分组进行直插排序 int t =j; int temp = a[j+span]; while (t&gt;-1&amp;&amp;a[t]&gt;temp){ a[t+span] = a[t]; t -= span; } a[t+span] = temp; } } } return a; } 8.基数排序8.1.思想基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 8.2算法描述取得数组中的最大数，并取得位数；arr为原始数组，从最低位开始取每个位组成radix数组；对radix进行计数排序（利用计数排序适用于小范围数的特点）； 8.3.动画演示 8.4代码实现基数（桶）借用链式队列数组，按位填入 public static int[] radix(int[] a,int m){//m表示最大整数有m位 LinkedBlockingQueue&lt;Integer&gt;[] bucket = new LinkedBlockingQueue[10];//因为是10进制，所以需要10个桶 for (int i=0;i&lt;bucket.length;i++){ //初始化每个队列 bucket[i] = new LinkedBlockingQueue(); } Integer pop; //保存从桶中弹出的数 for (int i=1;i&lt;=m;i++){ //根据位数遍历 for (int j=0;j&lt;a.length;j++){ //低位开始第i位，取出每个数字对应的位数作为桶下标， double val = Math.floor(a[j]/Math.pow(10,i-1))-10*Math.floor(a[j]/Math.pow(10,i));//取位公式 bucket[(int)val] .add(a[j]); //放入桶中 } int c=0; for (int k=0;k&lt;bucket.length;k++){ //遍历所有桶 while ((pop=bucket[k].poll())!=null){ //取出数据重新放入a中 a[c++] = pop; } } } return a; } 9.算法比较总结]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>tag 算法</tag>
        <tag>tag 排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本命令]]></title>
    <url>%2F2019%2F03%2F06%2Fgit%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[工作区-暂存区-本地仓库-远程仓库关系对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地仓库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。将本地仓库与远程仓库关联，然后可以将本地仓库内容推送到远程仓库中。 本地仓库基本操作创建本地仓库mkdir test #创建本地仓库工作目录 git init #初始化本地仓库 echo &quot;first file&quot; &gt;&gt; #test.txt 在工作目录test里添加文件 git add test.txt #将工作目录里的文件添加到暂存区 git commit -m &quot;first commit&quot; #将暂存区里的文件提交到版本地仓库 删除回退操作修改了文件内容并add了文件,但尚未commit,回退到修改前git reset HEAD test.txt git checkout -- test.txt 修改了文件内容并commit了文件，回退git log #拿到commit-id git reset --hard &quot;commit-id&quot; #执行回退 清空本地仓库git rm test.txt #删了文件，暂存区还有记录 git commit -m &quot;delete&quot; #提交删除，清空暂存区 远程仓库创建ssh key1.ssh-keygen -t rsa &quot;yourmail@example.com&quot; #创建ssh key 2.到用户目录下的.ssh文件夹 复制.pub到github构建ssh key 3.ssh -T git@github.com 测试是否连接成功 创建本地仓库，并提交到github远程仓库mkdir test2 echo &quot;test2&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;test2&quot; git remote add origin yourgithbub@name.git #添加一个新的远程仓库 git push -u origin master #(推送到远程仓库。-u等于关联，后面可以直接git push) 克隆远程仓库，修改文件并提交git clone yourgithub@name.git #克隆远程仓库 cd name #进入目录 echo &quot;clone add file&quot; &gt;&gt; test3.txt git add test3.txt git commit -m &quot;clone&quot; git push 标签关联git tag #列出所有标签 git tag v1.0.1 #新建标签v1.0.1 git tag -a tagName -m &quot;comment&quot; #创建tag并且添加了附注信息 git push origin --tags v1.0.1 #将tag推送到远程仓库 git tag -d tagName #删除tag 分支管理git branch #列出所有分支 git branch name #新建分支name git checkout name #切换到name分支 echo &quot;in branch&quot; &gt;&gt; branch.txt git add branch.txt git commit -m &quot;branch&quot; git push --set-upstream origin name #将name分支提交到远程仓库 check out master git merge name #合并分支 git branch -d name #删除分支 git fetch origin dev:dev #将远程的dev分支拉取到本地的dev分支 git pull origin master:brantest #pull=fetch+merge,将远程的mater分支fetch下来并和branchtest合并]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存模型]]></title>
    <url>%2F2019%2F03%2F06%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.首先看个整体图 2.内存模型解释2.1.程序计数器&nbsp;&nbsp;&nbsp;&nbsp;当前线程所执行字节码的行号指示器，通过改变它的值来选取下一条指令。分支、循环、异常处理、线程恢复等都需要依赖它。它也是唯一一个不会抛出OutOfMemoryError异常的区域。 2.2.虚拟机栈(java栈)&nbsp;&nbsp;&nbsp;&nbsp;java栈描述java方法执行的内存模型。一个方法的执行时，会虚拟机会创建一个栈帧，存储局部变量表，操作数栈等。方法的调用到执行结束，相当于java栈的入栈出栈。该区域可能会产生两种异常。线程请求的栈的深度大于虚拟机允许的最大深度，抛出StackOverflowError。若该栈支持动态拓展（一般都支持），扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。 2.3.本地方法栈&nbsp;&nbsp;&nbsp;&nbsp;本地方法栈与java栈功能差不多，只是java栈为java程序方法服务，而它为本地方法服务。有的虚拟机（如sun HotSpot）甚至会把二者合二为一。 如java栈一样，该区域也会抛StackOverflowError、OutOfMemoryError异常。 2.4.JAVA堆&nbsp;&nbsp;&nbsp;&nbsp;对于大多数应用来说，java堆是虚拟机管理的内存中分配最大的一部分。java堆是被所有线程共享的一块内存区域。&nbsp;&nbsp;&nbsp;&nbsp;虚拟机启动时便创建。存放对象实例，几乎所有的对象实例都在这里分配内存。该区域也是垃圾收集器管理的主要区域，因此很多时候也被称为GC堆。&nbsp;&nbsp;&nbsp;&nbsp;细分出来，该区域可以分为新生代，老年代，新生代可以再分为一个Eden空间，两个Survivor空间（from survivor，to survivor）。不论如何划分，存放的始终是实例对象。进一步划分的目的是利于回收内存，或者更快的分配内存。(内存收集器基本采用分代收集的方法)&nbsp;&nbsp;&nbsp;&nbsp;java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，且堆无法再拓展，将会抛出OutOfMemoryError异常。 2.5.方法区&nbsp;&nbsp;&nbsp;&nbsp;方法区与java堆一样，都是线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT)编译后的代码等数据。java虚拟机规范把方法区描述为java堆的一个逻辑部分，习惯在HotSpot虚拟机上开发的程序员更愿意称其为”永久代”。&nbsp;&nbsp;&nbsp;&nbsp;当方法区无法满足内存分配需求时，将会抛出OutOfMemoryError异常。 2.6.运行时常量池&nbsp;&nbsp;&nbsp;&nbsp;运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后将进入方法区的运行时常量池中存放。&nbsp;&nbsp;&nbsp;&nbsp;作为方法区的一部分，运行时常量池受内存限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 3.一个对象的一辈子&nbsp;&nbsp;&nbsp;&nbsp;我是一个普通的java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。 &nbsp;&nbsp;&nbsp;&nbsp;1、一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。&nbsp;&nbsp;&nbsp;&nbsp;2、并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。&nbsp;&nbsp;&nbsp;&nbsp;3、进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。&nbsp;&nbsp;&nbsp;&nbsp;分区的目的：新生区由于对象产生的比较多并且大都是朝生夕灭的，所以直接采用标记-清理算法。而养老区生命力很强，则采用复制算法，针对不同情况使用不同算法]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp开发过程中的乱码问题及其解决方案]]></title>
    <url>%2F2018%2F10%2F10%2Fjsp%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[jsp开发过程中的乱码问题及其解决方案1.必须先理清的关系jsp开发过程中,我们会看到page指令里有pageEncoding，contentType里的charset（后面一律简称charset),而浏览器自己也可以设置页面的编码格式。首先，pageEncoding表明，你这个文件将以什么编码形式保存起来。charset表明，你希望这里的代码以什么编码展示在浏览器上。浏览器自己也可以设置编码方式，当你的charset与浏览器不对应时就会出现乱码。 2.常见的几种编码 ISO-8895-1编码是单字节编码，因而可以达到数据无损,但不支持中文。 UTF-8编码多字节编码，支持中文等多种语言，是很通用的编码方式 gbk2312编码是针对中文而弄的一种编码 … 3.必须要知道的一些默认编码首先，get请求和post请求携带参数的方式不同（get直接在url上) 对于post请求，中文编码方式会受到上面提到的pageEncoding，charset，以及jsp内置对象request和response的setCharacterEncoding方法影响，后面会具体说明。 对于get请求，其中文编码会受到charset以及Tomcat服务器的配置信息影响，配置的是URLEncoding，在/conf/servlet.xml的文件中。据了解，Tomcat7及以下，默认采用ISO-8895-1,Tomcat8及以上采用UTF-8。 jsp中,request对象获取参数中需要特别注意到的一点是，对于get请求，采用request.getQueryString()得到的参数和用request.getParameter()得到的参数编码是不同的，因为方法getParameter()将会采用Tomcat服务器配置的URLEncoding自动解码一次,而getQueryString()会受到charset的影响 4.正式讲讲jsp中的编码问题 首先强调一点，内置对象的setCharacterEncoding只对post请求有效 对于post请求，当发送端用了response.setCharacterEncoding(Xxx),即设置了响应的编码格式，那么在服务器端，你可以选择用request.setCharacterEncoding(Xxx),即设置请求的编码方式来解决中文乱码问题。这一Xxx是必须一致的，response对应request。又或者，你可以自己手动转码的方式，把通过request.getParameter()得到的乱码数据data采用java.net.URLDecoder.decode(data, “Xxx”)或者new String(data.getBytes(“ISO-8895-1”),”Xxx”)从而解决乱码问题。当发送端没有设置response.setCharacterEncoding，那么此时需要参照contentType里的charset,这里的charset等价于上面的Xxx,依然可以用上述两种方式解决乱码问题。举个例子,A页面charset是utf-8，response.setCharacterEncoding是gbk2312，此时打开浏览器会是乱码，可以设置浏览器的编码为gbk，编码正常，而B页面charset也是utf-8，request.setCharacterEncoding必须是gbk，打印获取到的结果，在浏览器上还是乱码，因为浏览器在上一步被你设置成了gbk，换行utf-8正常。所以尽量控制charset与setCharacterEncoding是一致的 对于get请求，发送端的中文编码取决charset设置的编码方式，假如是utf-8，到了服务端的时候，若使用request.getParameter()，而此时你的Tomcat的URLEncoding是UTF-8,那么会自动用utf-8帮你解码一次，因而是不会出现乱码的情况。此时如果调用getQueryString(),打印的结果就是用charset设置utf-8编码方式编码的结果，需要手动解码回正常中文。 有一种无法挽回的特殊情况是，对于get请求，若发送端你的charset设置的是gbk2312，到了服务器端，假如你的Tomcat的URLEncoding是UTF-8，你用request.getParameter()获取参数，整个过程就等价于数据用了gbk2312编码，却用了utf-8自动解码，这样就会造成数据无法转回来了。当然此时你通过getQueryString()得到的数据通过解gbk2312码是可以得到正常结果的。 5.建议 控制contentType里的charset与pageEncoding与setCharacterEncoding()一致 对于中文数据尽量不用get请求提交，毕竟可能会造成上述说的无法挽回的结果。 可以设置拦截器，对请求统一进行编码，就不用一个页面调用设置编码的函数了]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jsp</tag>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈社团招新]]></title>
    <url>%2F2018%2F09%2F06%2F%E8%B0%88%E7%A4%BE%E5%9B%A2%E6%8B%9B%E6%96%B0%2F</url>
    <content type="text"><![CDATA[1 自从开学后，就开始准备招新事宜，我留任校团委网络中心，已经大三的我，不论当时留下来的原因是什么，如今尘埃落定，居其位,思其责，做其事。我其实很想逃避这些东西，但如今我逃避不了了。谈起招新，谈起扫楼，谈起跟其他组织竞争，可能有人会在背后说闲话，但我只能说，我只是在尽力做我能做的事情，没有恶意，我只是提供了一个选择，一个通往我部门的选择而已。但似乎，从其他人眼中，我所做的似有不妥。可能毕竟是竞争，可能我做的还不够好。 2我渐渐觉得社团是一个很迷的地方。如果一个人，坚持了一开始的想法，那么可能他就是体验社团一年，尝尝新鲜感，留下美好的回忆，然后大二离场。有的人，开始很融入这个社团，然后开始改变自己，改变想法，成功地走上了一条新的路，或者说被社团改造。我不能说这两种情况哪一个比较好，毕竟未来谁能预料地到。社团这条路，一开始，一群人挤着抢着上车，司机也各显神通地邀请，然而讽刺的是，到最后，幸运的人成功的进入了社团，可怜的人，从被抢来抢去，到被抛来抛去，最后再也鼓不起勇气去报其他。而更讽刺的是，某些幸运的人没有做出他应该做到的表现，而当时如果招入的是其他人，结局也又未可知。这时，我们往往会说，这就是命，或者说，缘分使然，感怀亦是徒然。 3不知为何，我开始会想很多东西，考虑很多东西，我开始担心自己做的不够好，我甚至害怕带不起他们。我开始为这些事操心，明明，我应该大胆放手，让他们成长。我似乎很自卑，但在一部分人眼中，我好像也很“完美”。我感觉我变了，我开始想写一些感受，我的话开始变的很多。 4我的大学只选择了一个社团，可能我是无法体会到那些报了多个社团的人的感受，我甚至都无法去评论，因为那样显得很片面。而有的人也是只选择了一个社团，但是他却也局限于只了解这一社团，似有井底之蛙之嫌。谈到社团，却又不得不提归属感一词，有的人愿意为部门付出很多，而且无怨无悔，甚至乐此不疲，而有的人唯恐避之不及。有的人只想得到什么，不打算去付出。我不知道每一个他们是怎么想的，我也不知道他们是否认真考虑过它的意义。或许是我的成长环境决定了我的所思所想，在外人看来觉得完全没有必要去做某些我认为才是真正该做该学的事。但想回来，我应该是个利己主义者，但为何偏偏去替他人担忧他的未来。是因为他们过的比我洒脱，我需要自我安慰自己？我想有部分原因是这样的。可是明明，我对自己的未来都没能把控好，但何苦去评判他人。这一点，我不知道为什么，或者说，我还没能想到这一层。 5走走停停，大学就这么过去了，可能毕业后的自己，回想如今，又是千思百绪，又或者嘲笑自己。甚至于说，多年之后，我才记起，我在大三的招新工作里，写了这么一篇文章。如果现在的我，无意间翻到了初中时的我写的东西，多么稚嫩，却也很美好。]]></content>
      <categories>
        <category>我说</category>
      </categories>
      <tags>
        <tag>生活闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http模拟登陆]]></title>
    <url>%2F2018%2F09%2F03%2Fhttp%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[使用java作为后台语言，实现带验证码的模拟登陆。采用springboot快速开发。简单而言，过程分两步 一、获取验证码图片通过抓包工具如fiddler等，或者直接在浏览器控制台找到获取验证码图片的url。然后后台发起http请求，拿到图片并展示。 如下获取验证码图片函数 private void getImg(HttpServletResponse response){ HttpGet get = new HttpGet(&quot;验证码的url&quot;); try { CloseableHttpResponse res = client.execute(get); HttpEntity entity = res.getEntity(); OutputStream out = response.getOutputStream(); byte[] buffer = new byte[1024]; int end; while ((end=entity.getContent().read(buffer))!=-1){ out.write(buffer); } out.close(); response.setContentType(&quot;image/jpeg&quot;);//设置相应类型,告诉浏览器输出的内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);//设置响应头信息，告诉浏览器不要缓存此内容 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); // 将内存中的图片通过流动形式输出到客户端 } catch (IOException e) { e.printStackTrace(); } 二、模拟登陆通过抓包工具如fiddler等，或者直接在浏览器控制台拿到模拟登陆所需要的参数的键值，后台拼接参数后向对应的路径发送请求，一般是post请求，就能正常模拟登陆成功了。 public void doLogin(@RequestParam(&quot;stuid&quot;)String stuid, @RequestParam(&quot;password&quot;)String password, @RequestParam(&quot;code&quot;) String code, HttpServletResponse response2) throws IOException { HttpPost post = new HttpPost(&quot;登陆的url&quot;); //装填参数 List&lt;NameValuePair&gt; nvps = new ArrayList&lt;NameValuePair&gt;(); nvps.add(new BasicNameValuePair(&quot;参数1&quot;,&quot;值1&quot;)); nvps.add(new BasicNameValuePair(&quot;参数1&quot;,&quot;值2&quot; )); post.setEntity(new UrlEncodedFormEntity(nvps, &quot;UTF-8&quot;)); post.setHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); post.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;); CloseableHttpResponse response = client.execute(post); response.close(); 难点模拟难点在于控制cookie的一致，或者说要保证获取验证码时的会话要跟提交参数登陆时的会话保持一致，这样保证验证码是正确的。代码中httpclicent对象最好是全局变量，这样会自动帮我们维持cookie的一致性（同一对象等价于同一个cookie)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First]]></title>
    <url>%2F2018%2F08%2F25%2FFirst%2F</url>
    <content type="text"><![CDATA[这是我的第一个博客，喜欢鼓捣很多东西]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
